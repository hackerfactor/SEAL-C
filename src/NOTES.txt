================================
Although the source files say cpp and hpp, and it uses g++ to compile, the code itself is written in C, not C++.
Why?
1. I like the more verbose error messages that come from g++ instead of gcc.
2. Maximum portability. Some C++ features don't transfer well between different C++ compilers.
3. It grants the ability to link to both C and C++ libraries (if there are any future dependencies).

In particular, this code contains no classes, no templates, and no overloading.
  - Complex templates often have a portability problem between compilers.
  - Complex classes can become a readability nightmare due to deep nesting.
  - Overloading can create debugging and readability problems if the remapping is not a direct comparison. (E.g., does "string + string" contatenate, add, or do something else? Yes -- it all depends on who defined the overloading.)


================================
The different types of output:

ERROR: to stderr = fatal and an abort.
ERROR: to stdout = non-fatal, indicates skipping a file.
WARNING: to stdout = notice to user

If line begins with "[...]", then it indicates the current file processing.
If line begins with a letter, then it's a message related to the current file.

Important:
Every "ERROR" and "WARNING" message must be unique.
This way, if a user reports a problem, we can easily search through the code for the error message.

================================
For creating a signed file:
There are a couple of options:

(A) Compute everything then write the file once.
    This is the "hard way" because the digest needs to be computed in parts.

(B) Write and update
    1. Write a stub to the file that includes a placeholder signature.
    2. Compute the new signature.
    3. Update the file with the new signature.
    This is the "easy way" for static files.

(C) Compute as you go and append the signature.
    This is expected for live-stream signing.

